---
description: Explains google-genai Function Calling Utilities, including schema generation (manual/auto), Tool definition, and the function invocation cycle.
globs: 
alwaysApply: false
---
# Chapter 5: Function Calling Utilities

In [Chapter 4: Chat / AsyncChat](chat___asyncchat.mdc), we explored how to manage conversational history using the `Chat` object. However, many advanced AI applications require the model to interact with the external world—fetching real-time data, accessing databases, or calling other APIs. This chapter delves into the Function Calling Utilities, a set of features designed to seamlessly integrate external tools and functions with the generative model.

## Motivation and Use Case

Generative models are powerful but inherently limited to the information they were trained on and the context provided in the prompt. Function calling allows the model to request the execution of predefined functions (tools) when it determines they are needed to fulfill a user's request. This bridges the gap between the model's knowledge and real-time or proprietary information.

Manually handling this process involves:
1.  Defining the function's interface (name, description, parameters, types) in a specific JSON schema format.
2.  Passing this schema to the model.
3.  Parsing the model's response to detect a function call request.
4.  Extracting the function name and arguments.
5.  Validating and potentially coercing arguments from JSON types to Python types.
6.  Executing the corresponding Python function.
7.  Formatting the function's return value into a specific JSON response format.
8.  Sending this response back to the model to continue the generation.

This cycle is complex and repetitive. The Function Calling Utilities in `google-genai` abstract away much of this complexity, especially through automatic schema generation and invocation handling.

**Central Use Case:** You want the model to answer questions about current weather conditions. Since the model's training data is not real-time, you need to provide it with a tool (a Python function) that can fetch live weather data.

```python
# Assuming 'client' is configured
from google.genai import types

# Define the Python function the model can call
def get_current_weather(location: str) -> str:
    """Returns the current weather for a specified location.

    Args:
        location: The city and state, e.g., "Boston, MA".
    """
    # In a real application, this would call a weather API
    print(f"--- Tool: Called get_current_weather(location='{location}') ---")
    if "boston" in location.lower():
        return "The weather in Boston is sunny and 75°F."
    else:
        return f"Sorry, I don't have weather information for {location}."

# Pass the function directly as a tool
# The SDK automatically generates the schema and handles the call cycle
response = client.models.generate_content(
    model='gemini-1.5-flash', # Use a model supporting function calling
    contents="What's the weather like in Boston right now?",
    config=types.GenerateContentConfig(
        tools=[get_current_weather] # Pass the function object
    )
)

# The response contains the final text after the function call
print(f"\nAI: {response.text}")
```
In this example, the SDK inspects `get_current_weather`, creates the necessary `FunctionDeclaration` schema, sends it to the model, detects the `FunctionCall` in the model's *intermediate* response, executes `get_current_weather` with the arguments provided by the model, sends the result back as a `FunctionResponse`, and returns the final, user-facing text generated by the model based on the weather information.

## Key Concepts

### 1. Tool and Function Declaration

*   **`types.FunctionDeclaration`:** Represents the schema of a single function that the model can call. It includes:
    *   `name`: The function's name.
    *   `description`: A description of what the function does (crucial for the model to understand when to use it).
    *   `parameters`: A `types.Schema` object defining the function's parameters (their names, types, descriptions, and whether they are required). The schema follows a subset of the OpenAPI 3.0 specification.
*   **`types.Tool`:** A container for grouping one or more `FunctionDeclaration` objects. It's the primary way to provide tool definitions to the model via the `config` parameter in methods like `generate_content` or `send_message`. You can also define other types of tools here (like `retrieval` or `google_search_retrieval`), but we focus on functions.

You can define these manually:

```python
from google.genai import types

# Manual Function Declaration
weather_func_decl = types.FunctionDeclaration(
    name='get_current_weather_manual',
    description='Get the current weather in a given location (Manual Decl)',
    parameters=types.Schema(
        type=types.Type.OBJECT,
        properties={
            'location': types.Schema(type=types.Type.STRING, description='The city and state')
        },
        required=['location']
    )
)

# Create a Tool containing the declaration
manual_tool = types.Tool(function_declarations=[weather_func_decl])

# Use this tool in generate_content config (manual handling needed for invocation)
# config = types.GenerateContentConfig(tools=[manual_tool])
print(f"Manual Tool: {manual_tool.function_declarations[0].name}")
```
While manual definition provides fine-grained control, it's often verbose.

### 2. Automatic Schema Generation

This is a major convenience feature. Instead of manually creating `FunctionDeclaration`, you can often pass Python callable objects (functions, methods) directly within the `tools` list in `GenerateContentConfig`.

*   **Mechanism:** The SDK uses utilities in `google/genai/_automatic_function_calling_util.py`, specifically the `_parse_schema_from_parameter` function (used internally by `FunctionDeclaration.from_callable`), to inspect the Python callable:
    *   **Name:** Taken directly from the function name (`__name__`).
    *   **Description:** Extracted from the function's docstring.
    *   **Parameters:** Derived from the function's signature (`inspect.signature`):
        *   Parameter names are used directly.
        *   Parameter types (`types.Schema.type`) are inferred from Python type hints (`str` -> `STRING`, `int` -> `INTEGER`, `float` -> `NUMBER`, `bool` -> `BOOLEAN`, `list` -> `ARRAY`, `dict` -> `OBJECT`). It also supports `typing.Union`, `typing.Optional`, `typing.Literal` (string enums), and Pydantic models.
        *   Parameter descriptions are parsed from the `Args:` section of the docstring (Numpy/Google style).
        *   Required parameters are inferred based on whether a parameter has a default value.
        *   Pydantic models are automatically converted into nested `OBJECT` schemas.

```python
# Function with type hints and docstring
def get_order_details(order_id: int, include_history: bool = False) -> dict:
    """Fetches details for a specific order.

    Args:
        order_id: The unique identifier for the order.
        include_history: Whether to include past order events. Optional.
    """
    # ... implementation ...
    return {"order_id": order_id, "status": "shipped", "history_included": include_history}

# The SDK uses this function to generate a FunctionDeclaration equivalent to:
# types.FunctionDeclaration(
#     name='get_order_details',
#     description='Fetches details for a specific order.',
#     parameters=types.Schema(
#         type=types.Type.OBJECT,
#         properties={
#             'order_id': types.Schema(type=types.Type.INTEGER, description='The unique identifier for the order.'),
#             'include_history': types.Schema(type=types.Type.BOOLEAN, description='Whether to include past order events. Optional.', nullable=True, default=False) # Default value captured
#         },
#         required=['order_id'] # order_id has no default, so it's required
#     )
# )
```
This automatic conversion significantly simplifies tool definition.

### 3. Automatic Function Invocation Cycle

When you provide Python callables as tools *and* leave automatic function calling enabled (the default), the SDK manages the entire invocation loop.

*   **Mechanism:** Utilities in `google/genai/_extra_utils.py` handle this:
    1.  **Detection:** After the model responds, the SDK checks `response.candidates[...].content.parts` for any `Part` containing a `function_call` ([Chapter 2: Content / Part](content___part.mdc)).
    2.  **Mapping:** It uses `get_function_map` to retrieve the actual Python function object corresponding to the `function_call.name` from the tools provided in the initial config.
    3.  **Argument Conversion:**
        *   It calls `convert_number_values_for_dict_function_call_args` to handle potential float-to-int conversions for numeric arguments received from the JSON payload.
        *   Crucially, `convert_argument_from_function` and `convert_if_exist_pydantic_model` are used. These functions compare the arguments received from the model (`function_call.args`, which is a `dict`) with the type hints in the target Python function's signature. They perform type coercion (e.g., JSON string to Python `datetime` if hinted) and automatically validate and instantiate Pydantic models if the corresponding parameter is type-hinted with a Pydantic model class. This ensures the arguments passed to your Python function match its expected types.
    4.  **Invocation:** `invoke_function_from_dict_args` (or `invoke_function_from_dict_args_async` for async functions) is called to execute the Python function with the converted arguments.
    5.  **Response Formatting:** The return value (or caught exception) from the Python function is wrapped in a dictionary (`{'result': ...}` or `{'error': ...}`) and formatted into a `types.Part` containing a `types.FunctionResponse` using `types.Part.from_function_response`.
    6.  **Resubmission:** The SDK internally sends a new request to the model, including the original user prompt, the model's `function_call` request, and the newly generated `function_response` part.
    7.  **Final Response:** The model processes the function result and generates the final response, which is then returned to the user by the initial `generate_content` call.

This automatic cycle hides the multi-step interaction with the model from the developer for the common case.

### 4. Manual Function Invocation Cycle

You can disable automatic function calling by setting `automatic_function_calling=types.AutomaticFunctionCallingConfig(disable=True)` in `GenerateContentConfig`.

*   **Process:**
    1.  Provide tools (manually defined `types.Tool` or Python callables for schema generation).
    2.  Call `generate_content`.
    3.  The `GenerateContentResponse` will contain the `function_call` in `response.candidates[...].content.parts` (or more easily via `response.function_calls`). The `response.text` will likely be empty or None.
    4.  *You* manually extract the function name and arguments (`response.function_calls[0].name`, `response.function_calls[0].args`).
    5.  *You* find and execute your Python function (potentially using helpers like `_extra_utils.convert_argument_from_function` and `_extra_utils.invoke_function_from_dict_args` if desired, or doing conversion manually).
    6.  *You* format the result using `types.Part.from_function_response`.
    7.  *You* make a *second* call to `generate_content`, providing the *full history*: original user `Content`, the model's `Content` containing the `function_call` part, and your new `Content` (role='tool') containing the `function_response` part.
    8.  The response from this second call will contain the final text.

This gives more control but requires managing the conversational state explicitly, similar to how [Chat / AsyncChat](chat___asyncchat.mdc) manages history.

## Usage Examples

### Automatic Function Calling (Recommended)

```python
# Assuming client and get_current_weather function are defined

response = client.models.generate_content(
    model='gemini-1.5-flash',
    contents="Any chance of rain in Boston today?",
    config=types.GenerateContentConfig(
        tools=[get_current_weather] # Just pass the function
    )
)
# SDK handles the intermediate call/response automatically.
print(response.text) # Contains the final answer using weather info.
```

### Manual Function Calling

```python
# Assuming client and get_current_weather function are defined
# Manual tool definition (or pass the function for auto-schema)
weather_func_decl = types.FunctionDeclaration.from_callable(
    client=client, callable=get_current_weather)
manual_tool = types.Tool(function_declarations=[weather_func_decl])

# --- First call: Get the function call request ---
user_prompt_content = types.UserContent(parts=["Is it sunny in Boston?"])
response1 = client.models.generate_content(
    model='gemini-1.5-flash',
    contents=[user_prompt_content],
    config=types.GenerateContentConfig(
        tools=[manual_tool], # Provide schema
        automatic_function_calling=types.AutomaticFunctionCallingConfig(disable=True) # Disable auto call
    )
)

# --- Manually process the function call ---
func_call = response1.function_calls[0] if response1.function_calls else None
if func_call and func_call.name == 'get_current_weather':
    print(f"Manual: Model requested call: {func_call.name}({func_call.args})")
    try:
        # Manually invoke (could use _extra_utils helpers)
        weather_result = get_current_weather(**func_call.args)
        func_response_payload = {'result': weather_result}
    except Exception as e:
        func_response_payload = {'error': str(e)}

    # Format the response part
    func_response_part = types.Part.from_function_response(
        name=func_call.name,
        response=func_response_payload
    )
    tool_response_content = types.Content(role='tool', parts=[func_response_part])

    # --- Second call: Send the function response back ---
    response2 = client.models.generate_content(
        model='gemini-1.5-flash',
        contents=[
            user_prompt_content,          # Original user prompt
            response1.candidates[0].content, # Model's request
            tool_response_content         # Our function result
        ],
        config=types.GenerateContentConfig(tools=[manual_tool]) # Keep tools for context
    )
    print(f"Manual Final AI: {response2.text}")
else:
    print(f"Manual Final AI (no function call): {response1.text}")

```

## Internal Implementation

### Automatic Schema Generation (`_automatic_function_calling_util.py`)

When `types.FunctionDeclaration.from_callable` is invoked (explicitly or implicitly when a function is passed in `tools`), it uses `inspect` to analyze the function signature and docstring. The core logic lies in `_parse_schema_from_parameter`.

**Simplified Flow (`_parse_schema_from_parameter`):**

1.  **Check Builtins:** If the type hint is a basic Python type (`str`, `int`, `list`, `dict`, etc.), map it directly to a `types.Type` enum. Check if `default` value is compatible.
2.  **Handle Unions/Optional:** If it's `typing.Union` or `|` (Python 3.10+), recursively parse each type in the union. If `NoneType` is present, set `nullable=True`. Combine results using `anyOf` if multiple non-null types exist.
3.  **Handle Generics (`List`, `Dict`, `Literal`):**
    *   `List[T]`: Set type to `ARRAY`, recursively parse `T` for `items` schema.
    *   `Dict[K, V]`: Set type to `OBJECT`. Currently, detailed key/value type schemas aren't deeply represented, treated as a generic object.
    *   `Literal['a', 'b']`: Set type to `STRING`, add `['a', 'b']` to `enum`.
4.  **Handle Pydantic Models:** If the type hint is a `pydantic.BaseModel` subclass (checked via `_extra_utils.is_annotation_pydantic_model`), set type to `OBJECT`. Iterate through `model_fields`, recursively calling `_parse_schema_from_parameter` for each field to build the `properties` dictionary. Determine `required` fields based on field definitions.
5.  **Error:** If the type hint doesn't match any known pattern, raise a `ValueError`.

### Automatic Invocation (`_extra_utils.py`)

When automatic calling is enabled, the `Models.generate_content` method (or `Chat.send_message`) coordinates the cycle.

```mermaid
sequenceDiagram
    participant User as SDK User
    participant GenContent as generate_content()
    participant Model as Generative Model API
    participant ExtraUtils as _extra_utils
    participant PyFunc as Python Function (e.g., get_weather)

    User->>GenContent: Call generate_content(tools=[PyFunc], ...)
    GenContent->>Model: Send request (with auto-generated schema for PyFunc)
    Model-->>GenContent: Response with FunctionCall(name='PyFunc', args={...})
    GenContent->>ExtraUtils: get_function_map() -> returns PyFunc
    GenContent->>ExtraUtils: convert_argument_from_function(args, PyFunc)
    ExtraUtils-->>GenContent: converted_args (type-coerced, Pydantic validated)
    GenContent->>ExtraUtils: invoke_function_from_dict_args(converted_args, PyFunc)
    ExtraUtils->>PyFunc: Execute PyFunc(**converted_args)
    PyFunc-->>ExtraUtils: Return result
    ExtraUtils-->>GenContent: result
    GenContent->>ExtraUtils: Format result into FunctionResponse Part
    ExtraUtils-->>GenContent: func_response_part
    GenContent->>Model: Send 2nd request (history + func_call + func_response)
    Model-->>GenContent: Final Response (text based on func result)
    GenContent-->>User: Return Final Response
```

**Key Helper Functions (`_extra_utils.py`):**

*   `get_function_map`: Creates a `dict[str, Callable]` mapping function names to the actual Python function objects provided in the `tools` config.
*   `convert_number_values_for_dict_function_call_args`: Pre-processes arguments from the model, converting floats like `5.0` to integers `5` where appropriate.
*   `convert_if_exist_pydantic_model`: This is recursive. It checks if the expected Python type hint (`param.annotation`) for an argument is a Pydantic model. If so, and the received value is a dictionary, it attempts `annotation(**value)` to validate and instantiate the model. It also handles nested Pydantic models within lists or dicts, and checks union types. Raises `errors.UnknownFunctionCallArgumentError` on validation failure or type mismatch.
*   `convert_argument_from_function`: Orchestrates the conversion for all arguments of a function, calling `convert_if_exist_pydantic_model` for each parameter based on its type hint in the function signature.
*   `invoke_function_from_dict_args` / `invoke_function_from_dict_args_async`: Takes the *converted* arguments and the function object, then calls the function using `**converted_args`. Catches exceptions and wraps them in `errors.FunctionInvocationError`.
*   `get_function_response_parts` / `get_function_response_parts_async`: This function encapsulates steps 3-5 of the invocation cycle for convenience, often used internally during the automatic process.

These utilities ensure that the arguments passed to your Python function are type-safe and match the function's signature, even handling complex types like Pydantic models automatically.

## Conclusion

The Function Calling Utilities are a powerful feature of the `google-genai` SDK, enabling generative models to interact with external tools and data sources. The SDK provides significant convenience through automatic schema generation from Python functions (leveraging type hints and docstrings) and a fully managed automatic invocation cycle. Key components like `types.FunctionDeclaration`, `types.Tool`, and internal helpers in `_automatic_function_calling_util.py` and `_extra_utils.py` work together to handle schema conversion, argument parsing and validation (including Pydantic models), function execution (sync/async), and response formatting. While manual control is possible, the automatic features drastically simplify the integration of external capabilities into AI workflows.

Understanding how to define and use these tools is crucial for building sophisticated applications. Next, we'll look at how the SDK handles iterating over potentially large result sets returned by some API calls in [Chapter 6: Pager / AsyncPager](pager___asyncpager.mdc).


---

Generated by [Rules for AI](https://github.com/altaidevorg/rules-for-ai)