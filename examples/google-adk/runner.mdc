---
description: Tutorial chapter for google-adk's Runner, detailing its role in orchestrating agent execution, managing sessions, artifacts, memory, and selecting agents.
globs: 
alwaysApply: true
---
# Chapter 1: Runner

Welcome to the google-adk tutorial! This first chapter introduces the `Runner`, a fundamental component responsible for managing the entire lifecycle of an agent interaction within the framework.

## Motivation and Use Case

Imagine you have built an agent, perhaps using an LLM, that can interact with users. How do you actually *run* this agent? You need a system that can:

1.  Receive user input.
2.  Maintain the conversation history ([Session](session__session___basesessionservice_.mdc)).
3.  Manage persistent state ([State](state.mdc)).
4.  Handle file uploads/downloads (Artifacts).
5.  Potentially retrieve relevant long-term memories.
6.  Invoke the correct agent logic.
7.  Stream back the agent's response ([Events](event.mdc)).
8.  In complex systems with multiple agents, decide *which* agent should handle the current turn.

The `Runner` is the orchestrator that handles all these tasks. It acts as the main entry point for interacting with any agent built using `google-adk`.

**Central Use Case:** A user sends a message ("What's the weather in London?") to your weather agent via an application. The application uses a `Runner` instance. The `Runner` retrieves the ongoing conversation session, appends the new user message, determines the weather agent should handle it, calls the agent's execution logic, and streams the resulting events (like the agent thinking, calling a weather tool, and finally responding) back to the application.

## Key Concepts

*   **Orchestration:** The `Runner` coordinates the flow of information and control between the user, the agent(s), and various backing services.
*   **Agent Execution:** It provides methods like `run_async` (asynchronous, recommended for production) and `run` (synchronous wrapper for testing) to execute an agent turn. It also supports an experimental `run_live` for real-time streaming interactions (e.g., voice).
*   **Service Integration:** It requires and utilizes services for managing different aspects of the interaction:
    *   `BaseSessionService`: Manages conversational [Sessions](session__session___basesessionservice_.mdc), including history ([Events](event.mdc)) and [State](state.mdc).
    *   `BaseArtifactService`: Handles storage and retrieval of binary data (e.g., files uploaded by the user or generated by the agent). (Optional)
    *   `BaseMemoryService`: Provides access to long-term memory for the agent. (Optional)
*   **Agent Selection:** In systems with a hierarchy of agents (an agent containing sub-agents), the `Runner` determines which agent is best suited to handle the current turn based on the session history and agent capabilities (using `_find_agent_to_run`). It checks if the last responding agent can "transfer" control back up the hierarchy if needed.
*   **Input Processing:** Before invoking the agent, the `Runner` processes the incoming user message (`new_message`). This includes potentially saving any attached binary data as artifacts (if `save_input_blobs_as_artifacts` is true in the `RunConfig`) and appending the user message as an [Event](event.mdc) to the [Session](session__session___basesessionservice_.mdc).
*   **Event Streaming:** The `run_async` and `run_live` methods are asynchronous generators that `yield` [Events](event.mdc) as they occur during the agent's execution (e.g., intermediate thoughts, tool calls, final response parts).

## How to Use `Runner`

The `Runner` (or its convenient subclass `InMemoryRunner`) is the primary way you'll interact with your agents.

1.  **Initialization:** Create a `Runner` instance, providing the root [Agent](agent__baseagent___llmagent_.mdc) and the necessary services. For simple local testing, `InMemoryRunner` automatically sets up in-memory versions of the services.

```python
# Assuming 'my_root_agent' is an instance of BaseAgent (or LlmAgent)
# And 'my_session_service' implements BaseSessionService

from google.adk.runners import Runner
from google.adk.sessions.in_memory_session_service import InMemorySessionService
# from my_agents import my_root_agent # Your agent definition

# Example using a specific session service
session_service = InMemorySessionService() # Or DatabaseSessionService, etc.
runner = Runner(
    app_name="my_cool_app",
    agent=my_root_agent,
    session_service=session_service,
    # artifact_service=..., # Optional
    # memory_service=...,   # Optional
)

# --- OR ---

# For easy local testing with everything in memory:
from google.adk.runners import InMemoryRunner

in_memory_runner = InMemoryRunner(agent=my_root_agent, app_name="test_app")
```
*Technical Explanation:* The `Runner` requires `app_name` for identifying the application context, the `agent` which is the entry point to your agent logic, and a `session_service` to manage conversations. `artifact_service` and `memory_service` are optional depending on your agent's needs. `InMemoryRunner` simplifies setup by providing default in-memory services.

2.  **Execution:** Use `run_async` to process a new user message within a specific session.

```python
import asyncio
from google.genai import types

async def interact_with_agent(runner: Runner, user_id: str, session_id: str, message_text: str):
    new_message = types.Content(role="user", parts=[types.Part(text=message_text)])

    print(f"User ({user_id}/{session_id}): {message_text}")

    async for event in runner.run_async(
        user_id=user_id,
        session_id=session_id,
        new_message=new_message,
        # run_config=RunConfig(...) # Optional configuration
    ):
        print(f"Received Event: {event.model_dump_json(indent=2, exclude_none=True)}")
        if event.is_final_response() and event.content:
           final_text = "".join(part.text or "" for part in event.content.parts)
           print(f"Agent Response ({event.author}): {final_text}")

# Example usage:
# user = "user123"
# session = runner.session_service.create_session(app_name="my_cool_app", user_id=user)
# asyncio.run(interact_with_agent(runner, user, session.id, "Hello Agent!"))
```
*Technical Explanation:* `run_async` takes the `user_id` and `session_id` to identify the conversation context and the `new_message` (as a `google.genai.types.Content` object). It returns an `AsyncGenerator` yielding `Event` objects. You iterate through these events to process the agent's turn, including intermediate steps and the final response.

## Internal Implementation

Understanding how the `Runner` works internally helps in debugging and building more complex agent interactions.

**High-Level Flow (`run_async`)**

1.  **Span Start:** A tracing span `invocation` is started.
2.  **Session Retrieval:** The `Runner` calls `session_service.get_session` to fetch the specified [Session](session__session___basesessionservice_.mdc). If not found, it raises an error.
3.  **Context Creation:** An [InvocationContext](invocationcontext.mdc) is created (`_new_invocation_context`). This object holds all relevant information for this specific agent turn (session, services, user message, run config, unique invocation ID).
4.  **Input Processing:** If `new_message` is provided, `_append_new_message_to_session` is called.
    *   It checks `run_config.save_input_blobs_as_artifacts`. If true and an `artifact_service` exists, any `inline_data` in the message parts is saved using `artifact_service.save_artifact`, and the part is replaced with a text placeholder.
    *   An [Event](event.mdc) representing the user message is created and appended to the session using `session_service.append_event`. This event is *not* yielded back by `run_async`.
5.  **Agent Selection:** `_find_agent_to_run` is called to determine which agent ([Agent (BaseAgent / LlmAgent)](agent__baseagent___llmagent_.mdc)) should handle this turn. It starts from the root agent and checks the session history. It looks for the last non-user event. If that agent exists in the hierarchy and is "transferable" (an `LlmAgent` allowed to transfer to its parent), that agent is chosen. Otherwise, it defaults to the root agent.
6.  **Agent Execution:** The chosen agent is set in the `InvocationContext`. The `Runner` then calls `invocation_context.agent.run_async(invocation_context)`, effectively delegating the core logic to the selected agent.
7.  **Event Handling:** The `Runner` asynchronously iterates through the [Events](event.mdc) yielded by the agent's `run_async`.
    *   For each event, if it's *not* partial (`event.partial` is False), it means it's a significant step (like a tool call/response or final answer chunk), so it's appended to the session using `session_service.append_event`.
    *   *All* events (partial and non-partial) received from the agent are yielded back to the caller of the `Runner`'s `run_async`.

**Sequence Diagram (`run_async`)**

```mermaid
sequenceDiagram
    participant UserApp
    participant Runner
    participant SessionService
    participant ArtifactService
    participant ChosenAgent as Agent (BaseAgent / LlmAgent)

    UserApp->>+Runner: run_async(user_id, session_id, new_message)
    Runner->>+SessionService: get_session(app_name, user_id, session_id)
    SessionService-->>-Runner: session
    Runner->>Runner: _new_invocation_context(session, new_message, ...)
    alt new_message exists
        Runner->>Runner: _append_new_message_to_session(...)
        opt save_input_blobs_as_artifacts = true
            Runner->>+ArtifactService: save_artifact(...)
            ArtifactService-->>-Runner: (updates message parts)
        end
        Runner->>+SessionService: append_event(session, user_event)
        SessionService-->>-Runner:
    end
    Runner->>Runner: _find_agent_to_run(session, root_agent)
    Runner-->>Runner: chosen_agent
    Runner->>+ChosenAgent: run_async(invocation_context)
    loop Agent yields events
        ChosenAgent-->>-Runner: event
        opt event.partial is False
            Runner->>+SessionService: append_event(session, event)
            SessionService-->>-Runner:
        end
        Runner-->>-UserApp: yield event
    end
    ChosenAgent-->>-Runner: (iteration complete)
    Runner-->>-UserApp: (async generator finishes)

```

**Code Snippets (`runners.py`)**

*   `run_async` Entry Point & Session Handling:
    ```python
    async def run_async(
        # ... args ...
    ) -> AsyncGenerator[Event, None]:
        with tracer.start_as_current_span('invocation'):
            session = self.session_service.get_session(
                app_name=self.app_name, user_id=user_id, session_id=session_id
            )
            if not session:
                raise ValueError(f'Session not found: {session_id}')
            # ... create context, process message ...
    ```
    *Technical Explanation:* Starts tracing, retrieves the session using the injected `session_service`.

*   Input Message Processing:
    ```python
    def _append_new_message_to_session(
        # ... args ...
    ):
        # ... checks for parts ...
        if self.artifact_service and save_input_blobs_as_artifacts:
            for i, part in enumerate(new_message.parts):
                if part.inline_data is None: continue
                # ... save artifact ...
                self.artifact_service.save_artifact(...)
                # ... replace part with text placeholder ...
        event = Event(...) # User event
        self.session_service.append_event(session=session, event=event)
    ```
    *Technical Explanation:* Handles optional artifact saving for input blobs and appends the user message `Event` to the session via `session_service`.

*   Agent Selection Logic (Simplified Concept):
    ```python
    def _find_agent_to_run(
        self, session: Session, root_agent: BaseAgent
    ) -> BaseAgent:
        # Iterate backwards through non-user events in session.events
        for event in filter(lambda e: e.author != 'user', reversed(session.events)):
            # Check if event author is root_agent
            # Check if event author is a known sub_agent
            # Check if that sub_agent is transferable (_is_transferable_across_agent_tree)
                # If transferable, return that agent
            # If checks fail, continue loop
        # Default: return root_agent
        return root_agent
    ```
    *Technical Explanation:* Traverses session history to find the last agent that responded. If that agent can transfer control (is an `LlmAgent` not blocking parent transfer), it's selected. Otherwise, the `root_agent` is used.

*   Agent Invocation and Event Handling:
    ```python
    async def run_async(
        # ... setup code ...
    ):
        # ... find agent ...
        invocation_context.agent = self._find_agent_to_run(session, root_agent)
        # Delegate to the chosen agent
        async for event in invocation_context.agent.run_async(invocation_context):
            # Append non-partial events to session history
            if not event.partial:
                self.session_service.append_event(session=session, event=event)
            # Yield ALL events (partial or not) back to the caller
            yield event
    ```
    *Technical Explanation:* After selecting the agent, its `run_async` method is called with the `InvocationContext`. The `Runner` iterates through the yielded events, persists non-partial ones to the session, and forwards all events to the application using `yield`.

## Conclusion

The `Runner` is the central engine for executing agents in `google-adk`. It orchestrates the interaction flow, manages session context, integrates with essential services (session, artifact, memory), handles input processing, selects the appropriate agent for the turn, and streams events back to the caller. It provides the primary API (`run_async`) for developers to interact with their agent systems.

Now that you understand how an agent interaction is orchestrated, the next chapter will delve into the core building block itself: the [Agent (BaseAgent / LlmAgent)](agent__baseagent___llmagent_.mdc).


---

Generated by [Rules for AI](https://github.com/altaidevorg/rules-for-ai)