---
description: Guidelines for using flax
globs: 
alwaysApply: true
---
Flax NNX is a neural network library for JAX designed to enhance the developer experience by integrating *stateful object-oriented programming* with JAX's *functional paradigm*.
The core abstraction is `nnx.Module` (0), a standard Python class where state (parameters, batch statistics, RNG states) is held directly as attributes, typically wrapped in `nnx.Variable` (1) subtypes (e.g., `nnx.Param`, `nnx.BatchStat`). This allows for intuitive initialization and direct attribute access.

To bridge the gap with JAX's requirement for pure functions and immutable data structures (*pytrees*), NNX provides:
1.  A **Functional API** (2): Functions like `nnx.split`, `nnx.merge`, `nnx.state`, and `nnx.update` allow explicitly separating a Module's static structure (`GraphDef`) from its dynamic state (`GraphState`), which is a pytree of immutable `nnx.VariableState` (1) objects. `GraphDef` and `GraphState` (7) form the internal representation used by this API. `Filters` (5) are used extensively within this API to select specific parts of the state based on type, tags, or path.
2.  **Lifted Transforms** (3): Higher-level wrappers around JAX transformations (e.g., `nnx.jit`, `nnx.grad`, `nnx.vmap`) that implicitly handle the state splitting and merging via the Functional API (2), offering a more object-oriented interface to users.

Auxiliary components include:
- `nnx.Rngs` (4): Manages PRNG keys for reproducibility and simplified handling within `nnx.Module` methods.
- `nnx.Optimizer` (6): A helper class encapsulating a Module, its differentiable parameters (selected via `Filters` (5)), an Optax optimizer, and its state, simplifying the training loop update step.

Overall, NNX aims to provide the flexibility and ease-of-use of Python objects while retaining compatibility with the performance benefits of JAX's functional transformations.


**Source Repository:** [https://github.com/google/flax.git](https://github.com/google/flax.git)

```mermaid
flowchart TD
    A0["nnx.Module"]
    A1["nnx.Variable / nnx.VariableState"]
    A2["NNX Functional API (split/merge/state/update/graphdef)"]
    A3["NNX Lifted Transforms (jit, grad, vmap, scan, etc.)"]
    A4["nnx.Rngs"]
    A5["Filters (`filterlib`)"]
    A6["nnx.Optimizer"]
    A7["Graph Representation (GraphDef / GraphState)"]
    A0 -- "Contains / Holds state in" --> A1
    A0 -- "Uses for randomness" --> A4
    A2 -- "Operates on / Deconstructs ..." --> A0
    A2 -- "Produces / Consumes" --> A7
    A2 -- "Uses for selection" --> A5
    A3 -- "Operates on" --> A0
    A3 -- "Uses implicitly" --> A2
    A5 -- "Selects / Filters" --> A1
    A6 -- "Wraps / Manages" --> A0
    A6 -- "Updates state of" --> A1
    A6 -- "Uses for parameter selection" --> A5
    A7 -- "Contains immutable state" --> A1
    A4 -- "Manages RNG state via" --> A1
    A3 -- "Uses for selection (e.g., S..." --> A5
```

## Chapters

[nnx.Module](nnx_module.mdc)
[nnx.Variable / nnx.VariableState](nnx_variable___nnx_variablestate.mdc)
[nnx.Rngs](nnx_rngs.mdc)
[Filters (`filterlib`)](filters___filterlib__.mdc)
[NNX Lifted Transforms (jit, grad, vmap, scan, etc.)](nnx_lifted_transforms__jit__grad__vmap__scan__etc__.mdc)
[NNX Functional API (split/merge/state/update/graphdef)](nnx_functional_api__split_merge_state_update_graphdef_.mdc)
[Graph Representation (GraphDef / GraphState)](graph_representation__graphdef___graphstate_.mdc)
[nnx.Optimizer](nnx_optimizer.mdc)


---

Generated by [Rules for AI](https://github.com/altaidevorg/rules-for-ai)